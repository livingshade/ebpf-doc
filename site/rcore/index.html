<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://example.com/rcore/" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>migrate to rCore tutorial - ebpf Docs</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "migrate to rCore tutorial";
        var mkdocs_page_input_path = "rcore.md";
        var mkdocs_page_url = "/rcore/";
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> ebpf Docs
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../ebpf/">eBPF overview</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../zcore/">An implement in zCore</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="./">migrate to rCore tutorial</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#environment-setup">Environment Setup</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#install-dependencies">Install dependencies</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#change-config">Change config</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#migration">Migration</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#add-syscall-interface">Add syscall interface</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#implement-osutilsrs">Implement osutils.rs</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#bpf-map-operations">BPF map operations</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#add-user-program">Add user program</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#add-more-user-programs">Add more user programs</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#details-about-makefile">Details about Makefile</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#further-work">Further work</a>
    </li>
    </ul>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">ebpf Docs</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" alt="Docs"></a> &raquo;</li>
      <li>migrate to rCore tutorial</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="migrate-ebpf-to-rcore-tutorial">migrate eBPF to rCore tutorial</h1>
<p>This is a step-by-step tutorial of how to migrate eBPF to rCore.</p>
<h2 id="environment-setup">Environment Setup</h2>
<p>Note that rCore tutorial only provides rust user programs but their is no rust support for eBPF yet. In that case, we need to use uCore-test to compile the user programs because uCore and rCore share the same ABI.</p>
<p>First, clone the repo</p>
<pre><code class="language-bash">git clone https://github.com/cubele/rCore-Tutorial-Code-2022A rcore-ebpf
cd rcore-ebpf
</code></pre>
<h3 id="install-dependencies">Install dependencies</h3>
<p>We need rust, llvm, clang, qemu and musl toolchains.</p>
<pre><code class="language-bash"></code></pre>
<h3 id="change-config">Change config</h3>
<p>You need to mannually change the path config in <code>user/ebpf/build.sh</code>, you basically just need to change the prefix of <code>builddir, ucoredir, targetdir</code>, use absolute path.</p>
<pre><code class="language-bash">cd os8
make run
</code></pre>
<p>You should see that rCore is started and the application is running. Run <code>ebpf_user_loadprogextest</code> and <code>ebpf_user_kernmaptest</code> to see the effect.</p>
<h2 id="migration">Migration</h2>
<p>According to the [eBPF tutorial], we now needs to add some os-dependent code to make it work. We only needs to add the syscall interface and implement the <code>osutils.rs</code> to provide necessary kernel functions. </p>
<p>We should always bear in mind that rCore kernel has its own page table, rather than those share with user space, like Linux and zCore.</p>
<h3 id="add-syscall-interface">Add syscall interface</h3>
<p>We need to add the following syscall interface to <code>syscall.rs</code>:</p>
<p>First, add the syscall number to <code>syscall/mod.rs</code>:</p>
<pre><code class="language-rust">//! syscall/mod.rs
const SYSCALL_BPF: usize = 280; 
// ...
pub fn syscall(syscall_id: usize, args: [usize; 4]) -&gt; isize {
    match syscall_id {
        // ...
        SYSCALL_BPF =&gt; sys_bpf(args[0] as isize, args[1] as usize, args[2] as usize),
    }
</code></pre>
<p>Then, implement <code>sys_bpf</code></p>
<pre><code class="language-rust">//! syscall/ebpf.rs
pub fn sys_bpf(cmd: isize, bpf_attr: usize , size: usize) -&gt; isize {
    let ptr = bpf_attr as *const u8;
    let cmd = cmd as i32;
    use crate::ebpf::BpfCommand::*;
    if let Ok(bpf_cmd) = BpfCommand::try_from(cmd) {
        let ret = match bpf_cmd {
            BPF_MAP_CREATE =&gt; sys_bpf_map_create(ptr, size),
            BPF_MAP_LOOKUP_ELEM =&gt; sys_bpf_map_lookup_elem(ptr, size),
            BPF_MAP_UPDATE_ELEM =&gt; sys_bpf_map_update_elem(ptr, size),
            BPF_MAP_DELETE_ELEM =&gt; sys_bpf_map_delete_elem(ptr, size),
            BPF_MAP_GET_NEXT_KEY =&gt; sys_bpf_map_get_next_key(ptr, size),
            BPF_PROG_LOAD =&gt; todo!(),
            BPF_PROG_ATTACH =&gt; sys_bpf_program_attach(ptr, size),
            BPF_PROG_DETACH =&gt; sys_bpf_program_detach(ptr, size),
            BPF_PROG_LOAD_EX =&gt; sys_preprocess_bpf_program_load_ex(ptr, size),
        };
        if ret &lt; 0 {
            -1
        } else {
           ret as isize
        }
    } else {
        -1
    }
</code></pre>
<p>We just need to add the syscall interface and use a match to call the corresponding function. We pass the <code>attr</code> as argument and let the function to handle it. Note that <code>BpfCommand</code> is an enum that represents the command type following the Linux API.</p>
<p>And we are finished with the syscall interface. This is quite simple, isn't it?</p>
<h3 id="implement-osutilsrs">Implement <code>osutils.rs</code></h3>
<p>In <code>osutils.rs</code>, we need to implement the following parts:</p>
<ul>
<li>A trait <code>ThreadLike</code> that is an analog to Linux thread. It should have <code>get_pid</code>, <code>get_tid</code> and <code>get_name</code> methods. And the function <code>os_current_thread</code> that returns that thread-like object.</li>
</ul>
<p>In rCore, we know that <code>TaskControlBlock</code> is the thread-like object. So we can implement the trait for <code>TaskControlBlock</code> and return the current thread.</p>
<pre><code class="language-rust">impl ThreadLike for TaskControlBlock {
    fn get_pid(&amp;self) -&gt; u64 {
        let proc = self.process.upgrade().unwrap();
        return proc.pid.0 as u64;
    }
    fn get_tid(&amp;self) -&gt; u64 {
        return 0; // no viable in rcore tutor
    }
    fn get_name(&amp;self) -&gt; String {
        return String::from(&quot;not viable in rcore tutorial&quot;)
    }
}
</code></pre>
<p>Note that we don't have a tid in rCore. So we just return 0. And we don't have a process name. So we just return a dummy string. Also, we need to implement the <code>os_current_thread</code> function.</p>
<pre><code class="language-rust">pub fn os_current_thread() -&gt; Arc&lt;dyn ThreadLike&gt; {
    if let Some(thread) = crate::task::current_task() {
        thread
    } else {
        panic!(&quot;cannot get current thread!&quot;)
    }
}
</code></pre>
<ul>
<li><code>os_current_time</code> that returns the current time in nanoseconds. <code>os_get_current_cpu</code> that returns the current cpu id. <code>os_console_write_str</code> that writes a string to the console. Those are used in helper functions.</li>
</ul>
<pre><code class="language-rust">pub fn os_current_time() -&gt; u128 {
   crate::timer::get_time_us() as u128 * 1000
}

pub fn os_get_current_cpu() -&gt; u8 {
   0 // not viable
}

pub fn os_console_write_str(s: &amp;str) {
    crate::console::Stdout.write_str(s).unwrap();
}
</code></pre>
<p>Again, rCore a single-core system. So we just return 0 for <code>os_get_current_cpu</code>. And we use <code>Stdout</code> to write to the console.</p>
<ul>
<li><code>os_copy_from_user</code> and <code>os_copy_to_user</code> that copy data from/to user space. Because some OS use virtual memory, we need to translate the address. This two functions are primitives for other memory related functions like <code>get_generic_from_user</code> and all other syscall branches.</li>
</ul>
<pre><code class="language-rust">pub fn os_copy_from_user(usr_addr: usize, kern_buf: *mut u8, len: usize) -&gt; i32 {
    use crate::mm::translated_byte_buffer;
    use crate::task::current_user_token;
    let t = translated_byte_buffer(current_user_token(), usr_addr as *const u8, len);    
    let mut all = vec![];
    for i in t {
        all.extend(i.to_vec());
    }
    copy(kern_buf, all.as_ptr() as *const u8, len);
    0
}

pub fn os_copy_to_user(usr_addr: usize, kern_buf: *const u8, len: usize) -&gt; i32 {
    use crate::mm::translated_byte_buffer;
    use crate::task::current_user_token;
    let dst = translated_byte_buffer(current_user_token(), usr_addr as *const u8, len);
    let mut ptr = kern_buf;
    let mut total_len = len as i32;
    for seg in dst {
        let cur_len = seg.len();
        total_len -= cur_len as i32;
        unsafe {
            core::ptr::copy_nonoverlapping(ptr, seg.as_mut_ptr(), cur_len);
            ptr = ptr.add(cur_len);   
        }
    }
    assert_eq!(total_len, 0);
    0
}

// You don't need to change this two functions
pub fn copy(dst: *mut u8, src: *const u8, len: usize) {
    let from = unsafe { from_raw_parts(src, len) };
    let to = unsafe { from_raw_parts_mut(dst, len) };
    to.copy_from_slice(from);
}

pub fn memcmp(u: *const u8, v: *const u8, len: usize) -&gt; bool {
    return unsafe {
        from_raw_parts(u, len) == from_raw_parts(v, len)
    }
}
</code></pre>
<p>This part is very tricky, since rCore use different page table for kernel and user space. So for every pointer from user space, we needs to translate and copy it to kernel buffer and vice versa. We use <code>translated_byte_buffer</code> to translate the address, which is provided by <code>mm</code>.</p>
<p>It is worth note that for zCore, which use the same page table for kernel and user space, the two function is just a <code>memcpy</code>.</p>
<p>And that is all for <code>osutils.rs</code> ! You can refer to the source code to see we use this two primitives to build <code>get_generic_from_user</code>, and use that to get the <code>attr</code> from user space. And all other syscall branches are done. That is because their logic is os-independent, we only needs to provide a memory interface.</p>
<h3 id="bpf-map-operations">BPF map operations</h3>
<p>We don't need to change any code here, but I want to show that how different page table effect the migration.</p>
<p>Nte that functions like <code>bpf_map_lookup_elem</code> can be called both from kernel space and user space. It is nothing important in zCore, since zCore use the same page table for kernel and user space. But in rCore, we need to be especially careful.</p>
<p>When a user program wants to access a map, it needs to call <code>bpf_map_lookup_elem</code> in user space. And the syscall interface will call <code>sys_bpf_map_lookup_elem</code> in kernel space. In that case, address are from user space, and we need the additional translation.</p>
<p>But a loaded BPF program can access maps as well and it runs in kernel space. In that case, the address is from kernel space, and we don't need the translation.  </p>
<p>So, we need to pass a flag to tell the function whether the address is from user space or not. Argument <code>from_user: bool</code> in that case. For user program, it calls through <code>sys_bpf_map_...</code>, which passes <code>from_user = true</code>. For BPF program, it calls <code>bpf_helper_map_...</code>, which passes <code>from_user = false</code>.</p>
<p>Let's take a look at the code of <code>bpf_map_ops</code>, in which the actual map operations are done.</p>
<pre><code class="language-rust">pub fn bpf_map_ops(fd: u32, op: BpfMapOp, key: *const u8, value: *mut u8, flags: u64, from_user: bool) -&gt; BpfResult {
    let bpf_objs = BPF_OBJECTS.lock();
    let obj = bpf_objs.get(&amp;fd).ok_or(ENOENT)?;
    let shared_map = obj.is_map().ok_or(ENOENT)?;
    let mut map = shared_map.lock();
    if from_user {
        let key_size = map.get_attr().key_size;
        let value_size = map.get_attr().value_size;
        let mut key_kern_buf = alloc::vec![0 as u8; key_size];
        let kptr = key_kern_buf.as_mut_ptr();
        os_copy_from_user(key as usize, kptr, key_size);
        let mut value_kern_buf = alloc::vec![0 as u8; value_size];
        let vptr = value_kern_buf.as_mut_ptr();
        match op {
            BpfMapOp::LookUp =&gt; {
                let ret = map.lookup(kptr, vptr);
                os_copy_to_user(value as usize, vptr, value_size);
                ret
            },
            BpfMapOp::Update =&gt; {
                os_copy_from_user(value as usize, vptr, value_size);
                let ret = map.update(kptr, vptr, flags);
                ret
            },
            BpfMapOp::Delete =&gt; map.delete(kptr),
            BpfMapOp::GetNextKey =&gt; {
                let ret = map.next_key(kptr, vptr);
                os_copy_to_user(value as usize, vptr, value_size);
                ret
            }
            _ =&gt; Err(EINVAL),
        }
    } else {
        match op {
            BpfMapOp::LookUp =&gt; map.lookup(key, value),
            BpfMapOp::Update =&gt; map.update(key, value, flags),
            BpfMapOp::Delete =&gt; map.delete(key),
            BpfMapOp::GetNextKey =&gt; map.next_key(key, value),
            _ =&gt; Err(EINVAL),
        }
    }    
}
</code></pre>
<p>We can see that we need extra copy when <code>from_user</code> is true. And we use <code>os_copy_from_user</code> and <code>os_copy_to_user</code> to do the copy. For OS like zCore, those steps are redundant. An extra copy will make it run slower, but does not harm the correctness. This is the fundamental trade off between generality and performance.</p>
<h2 id="add-user-program">Add user program</h2>
<p>Now we need add user program that test our eBPF utility. There are 4 user tests.</p>
<ul>
<li><code>ebpf_user_naivetest.c</code> is a naive test that just call <code>sys_bpf</code> to test the syscall interface.</li>
<li><code>ebpf_user_maptest.c</code> is a test that test the map operations from user program.</li>
<li><code>ebpf_user_loadprogextest.c</code> is a test that load a BPF kernel program <code>context.c</code> from user program and print out the registers. This tests the kprobe and some helper functions.</li>
<li><code>ebpf_user_kernmaptest.c</code> is a test that load a BPF kernel program <code>map.c</code> from user program and test the map operations from kernel program. This tests the bpf map in kernel space.</li>
</ul>
<p>You can simple run them in <code>make run</code>.</p>
<h3 id="add-more-user-programs">Add more user programs</h3>
<p>If you want add more user programs, you need to add the source file in <code>ucore/src</code> just like the 4 tests above.</p>
<p>If you want to add kernel BPF programs and load them, you need to add the kernel source file in <code>user/ebpf/kern</code> just like <code>map.c</code> and <code>context.c</code>, and do the following thing:</p>
<pre><code class="language-bash"># suppose you add map2.c as kernal program
cd user/ebpf/kern
make
python3 hex2char.py 
# copy the output, which is the length of kern prog
# copy map2.dump to your user program, take ebpf_user_loadprogextest.c as example
</code></pre>
<p>That is because rCore tutorial does not support <code>mmap</code> or <code>malloc</code>, we have to mannually copy the byte code into a <code>char []</code> array. <code>hex2char.py</code> just read a ELF and print out its hex value byte by byte. We also have to mannually set the length of the program as argument. You can refer to zCore test program if you have implmented <code>mmap</code> or <code>malloc</code> and <code>fstat</code> for kernel.</p>
<p>Don't forget to change <code>build.sh</code> before you run <code>make run</code> in <code>os8</code></p>
<h3 id="details-about-makefile">Details about Makefile</h3>
<p>You can skip this section if you are not interested in the details. But if you want to migrate from scratch, you need to know the whole procedure.</p>
<p>We need to compile the user program and link it with our library. We just use uCore-Test's makefile because its compatitble with rCore. But for eBPF programs, we need a user library <code>bpf.h</code> and <code>bpf.c</code>, in <code>ucore/include</code>, <code>ucore/lib</code>, respectively.</p>
<p>When we call <code>make</code> in <code>/ucore</code>, it will compile the user program and the ELF is in <code>ucore/build/riscv64</code>.</p>
<p>Then we need to copy the elf to rCore's filesystem, which is done by <code>user/ebpf/build.sh</code>. In the script, we touch a empty file called <code>[testcase].rs</code> and copy the elf to target directory. Then we run <code>make run</code> in <code>os8</code>.</p>
<p>You can refer to makefile <code>fs-img</code> and <code>fn easy_fs_pack</code> for the reason. Those steps are quiet stupid and you might find better solution.</p>
<h2 id="further-work">Further work</h2>
<p>Currently, the symbol table is not supported, thus the kprobe attach target is hardcoded in <code>tracepoint.rs::resolve_symbol</code> as <code>sys_open</code>. You can try to support it by adding the symbol table utility. You can refer to zCore's implementation. </p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../zcore/" class="btn btn-neutral float-left" title="An implement in zCore"><span class="icon icon-circle-arrow-left"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../zcore/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
